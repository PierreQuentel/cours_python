@title Introduction à Python
@pagenum True
@index Introduction

Introduction à Python
=====================

<h2 style="padding-top:100px;padding-left:100px;">Adapté du [Tutoriel Python](http://docs.python.org/3.6/tutorial/index.html)</h2>


../..
Historique
==========
Créé en 1989 par Guido van Rossum

- version 2.0 en 2000
 - version courante 2.7.13

- version 3.0 en 2008 (quelques incompatibilités)
 - version courante 3.6.0
 - plus cohérent, "propre", meilleur support d'Unicode

- recommandation : __choisir Python3 pour les nouveaux projets__
 - sauf dépendance incontournable à une librairie pas encore migrée en Python 3

../..
Caractéristiques
================

- facile à apprendre
- structures de données de haut niveau
- orienté objet
- interprété
- extensible
- Open Source
- disponible et portable "tel quel" sur toutes les plateformes

- pratique plus que puriste
- permissif
- accent sur la lisibilité (indentation)
- typage fort, mais non déclaré
- puissant : coeur minimaliste, mais bibliothèque très étendue (UI, web, fichiers, bases de données, manipulation de texte...)
../..
Popularité
==========
<table cellspacing=10>
<tr>
<td style="font-size:18px;" valign="top">
Index [Tiobe](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html)</td>
<td><img src='tiobe.png' height=500></td>

</table>
../..
Popularité
==========
Index [PyPL](https://sites.google.com/site/pydatalog/pypl/PyPL-PopularitY-of-Programming-Language)
basé sur les recherches "tutorial <langage>" sur Google

<img src='pypl.png' height=400>

_"Worldwide, Java is the most popular language, Python grew the most in the last 5 years (7.6%) and PHP lost the most (-4.9%)"_
../..
Popularité
==========
Projets créés sur Github (aout 2014)

<img src='github.png' height=400>

../..
Popularité
==========
Largement utilisé par Google (dont GvR était salarié jusqu'en 2012, maintenant chez DropBox), sur Youtube

Mercurial est écrit en Python

Web frameworks : Django, Flask

Enseignement supérieur

Automatisation de tests, datamining, machine learning, sécurité

[Success stories](http://www.python.org/about/success/)

../..
Installation
============
Aller sur le [site](http://python.org) et suivre les instructions

L'installation crée une commande _python_ dans l'invite de commande, qui lance l'interpréteur interactif

<img src="python.png" height=500>
../..
Ressources
==========

- la documentation Python : [site Python](http://docs.python.org/3/),
  [tutoriel](https://docs.python.org/3/tutorial/index.html), doc Windows
- forums : [comp.lang.python](https://groups.google.com/forum/?fromgroups#!forum/comp.lang.python), [comp.lang.python.fr](https://groups.google.com/forum/?fromgroups#!forum/fr.comp.lang.python),
[reddit r/Python](http://www.reddit.com/r/Python/)
- [stackoverflow](http://stackoverflow.com/)

- [Python Package Index](http://pypi.python.org)
- [The Python Cookbook](http://aspn.activestate.com/ASPN/Python/Cookbook/)
../..
Commentaires
============
Introduits par #

    `python
    # ceci est le premier commentaire
    SPAM = 1                 # et ceci est le deuxième
                             # ... et encore un !
    STRING = "# Ceci n'est pas un commentaire."
../..
Définition de noms
==================

    >>> width = 20
    >>> width += 10
    >>> width
    30
    >>> height = 5 * 9

    >>> x = y = z = 0

    >>> a, b = 0, 1
../..
@index Chaines de caractères
Chaines de caractères
=====================
Utilise `'` ou `"`

    `python
    'spam eggs'
    "spam eggs"
    
    "doesn't"
    '"Yes," he said.'

`\` pour échappement

    `python
    'doesn\'t'
    "\"Yes,\" he said."
    '"Isn\'t," she said.'

../..
Chaines de caractères
=====================
`\` pour continuer une ligne

    `python
    hello = "This is a rather long string containing\n\
    several lines of text just as you would do in C.\n\
        Note that whitespace at the beginning of the line is\
     significant."

`"""` sur plusieurs lignes
    `python
    print("""
    Usage: thingy [OPTIONS]
         -h                        Display this usage message
         -H hostname               Hostname to connect to
    """)
../..
Chaines de caractères
=====================
Mode par défaut :

    >>> word = 'a\nb'
    >>> print(word)
    a
    b

Mode brut :

    >>> word = r'a\nb'
    >>> print(word)
    a\nb

../..
Chaines de caractères
=====================
Concaténation par `+`, duplication par `*`

    >>> word = 'Help' + 'A'
    >>> word
    'HelpA'
    >>> '<' + word * 5 + '>'
    '&lt;HelpAHelpAHelpAHelpAHelpA>'

../..
Chaines de caractères
=====================
Accès à un caractère par index
------------------------------

<pre>
 +---+---+---+---+---+
 | s | a | l | u | t |
 +---+---+---+---+---+
   0   1   2   3   4
  -5  -4  -3  -2  -1
</pre>

    >>> word = 'salut'
    >>> word[4]
    't'
    >>> word[-2]
    'u'
    >>> word[10]
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    IndexError: string index out of range
    >>>

../..
Chaines de caractères
=====================
Tranches (slices)
--------

<pre>
 +---+---+---+---+---+
 | s | a | l | u | t |
 +---+---+---+---+---+
   0   1   2   3   4
  -5  -4  -3  -2  -1
</pre>

Le premier indice est <b>compris</b>, le deuxième est <b>non compris</b>

    >>> word[0:2]
    'sa'
    >>> word[2:4]
    'lu'
../..
Chaines de caractères
=====================
On peut omettre les indices pour le début ou la fin de la tranche. Ou utiliser un indice trop grand.

    >>> word[:2]
    'sa'
    >>> word[3:]
    'ut'
    >>> word[3:100]
    'ut'

../..
Chaines de caractères
=====================
Tranches (slices) - autre explication
--------

En écrivant les indices avant les cases, cela permet de calculer plus facilement les slices.
<pre>
 +---+---+---+---+---+
 | s | a | l | u | t |
 +---+---+---+---+---+
 0   1   2   3   4   5
-5  -4  -3  -2  -1
</pre>

    >>> word[0:2]
    'sa'
    >>> word[2:4]
    'lu'
    >>> word[-3:]
    'lut'
    >>> word[3:]
    'ut'
    >>> word[3:100]
    'ut'

../..
Chaines de caractères
=====================
Test d'appartenance

    >>> s = 'abcde'
    >>> 'a' in s
    True
    >>> 'bcd' in s
    True
    >>> 'b' not in s
    False
    >>> 'x' in s
    False

../..
Chaines de caractères
=====================
Les chaines sont immuables

    >>> word = 'HelpA'
    >>> word[1] = 'a'
    TypeError: 'str' object does not support item assignment

Longueur d'une chaine

    >>> word = 'anticonstitutionnellement'
    >>> len(word)
    25

../..
@index Listes
Listes
======

    >>> a = ['spam', 'eggs', 100, 1234]
    >>> a
    ['spam', 'eggs', 100, 1234]

Accès par index ou par tranche

    >>> a[0]
    'spam'
    >>> a[3]
    1234
    >>> a[-2]
    100
    >>> a[1:-1]
    ['eggs', 100]
../..
Listes
======
Les listes sont mutables

    >>> a
    ['spam', 'eggs', 100, 1234]
    >>> a[2] += 23
    >>> a
    ['spam', 'eggs', 123, 1234]
../..
Listes
======
Concaténation par `+`, duplication par `*`

    >>> a = ['spam', 'eggs', 100, 1234]
    >>> 3 * a[:3] + ['Boo!']
    ['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']

Affectation et clonage

    >>> a = [0, 1]
    >>> b = a       # les noms 'a' et 'b' sont liés au même objet
    >>> b[0] = 9    # toute modification sur b modifie aussi a
    >>> a
    [9, 1]
    >>> b = a[:]    # clonage : création d'un objet différent de a
    >>> b[0] = 1
    >>> a
    [9, 1]
../..
Listes
======
Longueur d'une liste par `len`

    >>> a = ['a', 'b', 'c', 'd']
    >>> len(a)
    4
../..
Listes
======
Découper une chaine de caractères en éléments d'une liste : méthode `split()`

    >>> s = "La cigale et la fourmi"
    >>> s.split()
    ['La', 'cigale', 'et', 'la', 'fourmi']
    >>> s = "et un ! et deux ! et trois zéro !"
    >>> s.split('!')
    ['et un ', ' et deux ', ' et trois zéro ', '']

Transformer une liste de chaines en une seule chaine : méthode `join` appliquée au _séparateur_

    >>> a = ["O rage", "ô désespoir", "ô vieillesse ennemie"]
    >>> ' ! '.join(a)
    'O rage ! ô désespoir ! ô vieillesse ennemie'

../..
Listes
======
Une liste peut contenir d'autres listes
    
    >>> b = [2, 3]
    >>> a = [1, b, 4]
    >>> len(a)
    3
    >>> a[1]
    [2, 3]
    >>> a[1][0]
    2
../..
Listes
======
Ajout d'un élément à la fin d'une liste par `append`
    
    >>> t = [2, 3]
    >>> t.append('xtra')
    >>> t
    [2, 3, 'xtra']

Insertion d'un élément à une position donnée par `insert`

    >>> t.insert(1, 'new')
    >>> t
    [2, 'new', 3, 'xtra']
    >>>
../..
Listes
======

`del` pour supprimer des éléments

    >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
    >>> del a[0]
    >>> a
    [1, 66.25, 333, 333, 1234.5]
    >>> del a[2:4]
    >>> a
    [1, 66.25, 1234.5]
    >>> del a[:]
    >>> a
    []
../..
@index Tuples
Tuples
======
Comme une liste, mais immuable

    >>> t = (1, 2, 'a')
    >>> t[1]
    2
    >>> t[2] = 'b'
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: 'tuple' object does not support item assignment

../..
Tuples
======

C'est la virgule qui crée un tuple, pas la parenthèse

    >>> t = 1, 2
    >>> t
    (1, 2)

@pause
Tuple avec un seul élément

    >>> x = (1) # eh non !
    >>> x
    1
    >>> x = 1,
    >>> x
    (1,)

@pause
Tuple vide

    >>> t = ()
    >>> t
    ()

../..

@index Programmation
Premiers pas en programmation
=============================
Suite de Fibonacci

    >>> a, b = 0, 1
    >>> while b < 10:
    ...     print(b)
    ...     a, b = b, a + b
    ...
    1
    1
    2
    3
    5
    8

A noter :

- assignement multiple : `a, b = 0, 1`
- indentation
 - utiliser de préférence 4 espaces
- boucle `while`
../..
Indentation
===========
Un bloc commence après une ligne qui se termine par `:`

Toutes les lignes du même bloc doivent avoir la même indentation

    `python
    if condition:
        x += 1
       print('condition vraie') # indentation incorrecte !


../..
La fonction `print`
===================

    >>> i = 256 * 256
    >>> print('La valeur de i est', i)
    La valeur de i est 65536

../..
Conditions : `if, elif, else`
=============================

    >>> x = int(input("Please enter an integer: ")) # "raw_input" en Python 2
    Please enter an integer: 42
    >>> if x < 0:
    ...      x = 0
    ...      print('Negative changed to zero')
    ... elif x == 0:
    ...      print('Zero')
    ... elif x == 1:
    ...      print('Single')
    ... else:
    ...      print('More')
    ...
    More

nb : pas de "switch / case"
../..
Conditions
==========
Booléens : `True` et `False`

Test d'égalité : `==`, d'inégalité `!=`

    >>> 1 == 0
    False
    >>> 1 != 0
    True

Négation : `not`

    >>> not 1 == 0
    True
../..
Conditions
==========
Test sur les types intégrés : `False` pour un nombre égal à 0, une chaine vide,
une liste vide.

    `python
    x = []
    if not x: # plus pythonique que "if x == []:"
        print("x est vide")

@pause
Opérateur ternaire

    `python
    x = a[0] if a else None

../..
Conditions
==========
Test d'identité : `is`

    >>> a = [1, 2]
    >>> b = a[:]
    >>> a == b # tous les éléments de chaque liste sont-ils égaux ?
    True
    >>> a is b # est-ce le même objet ?
    False
    >>> c = a
    >>> a is c
    True



../..
@index Boucle "for"
Boucle `for`
============
Un des outils les plus puissants de Python

    >>> animal_list = ['chat', 'chien', 'oiseau']
    >>> for animal in animal_list:
    ...     print(animal, len(animal))
    ...
    chat 4
    chien 5
    oiseau 6

L'itération par `for ... in` permet de manipuler des *valeurs* plutôt que des *index*.

../..
Boucle `for`
============
Itération sur une chaine de caractères:

    >>> for car in 'abcdef':
    ...     print(car)
    ...
    a
    b
    c
    d
    e
    f

../..
La fonction `range`
===================

    >>> for i in range(5):
    ...     print(i)
    ...
    0
    1
    2
    3
    4

syntaxe : `range(start, stop, step)` ou `range(stop)`
../..
Itérateurs
==========
__[Python 2]__

    >>> range(5)
    [0, 1, 2, 3, 4]
> `range` renvoie une liste

__[Python 3]__

    >>> range(5)
    range(0, 5)

> `range` renvoie un _itérable_ (un objet dont on peut parcourir les éléments un par un).

> Dans `for x in A`, *A* est un itérable.

> Certaines fonctions prennent un itérable comme argument, par exemple `list`.

    >>> list(range(5))
    [0, 1, 2, 3, 4]
../..
`continue`
==========

    >>> voyelles = 'aeiouy'
    >>> consonnes = ''
    >>> for car in 'une souris verte':
    ...     if car in voyelles or car == ' ':
    ...         continue
    ...     consonnes += car
    ...
    >>> consonnes
    'nsrsvrt'
    >>>
../..
`break`
=======

    >>> while True:
    ...     car = int(input('Entrer un nombre de 0 à 5: '))
    ...     if 0 <= car <= 5:
    ...         break
    ...
    Entrer un nombre de 0 à 5: 8
    Entrer un nombre de 0 à 5: 3
    >>>

../..
@index Fonctions
Fonctions
=========

    >>> def fib(n):
    ...     """Ecrit la suite de Fibonacci jusqu'à n."""
    ...     a, b = 0, 1
    ...     while a < n:
    ...         print(a, end=' ')
    ...         a, b = b, a + b
    ...     print()
    ...
    >>> fib(2000)
    0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
    >>>

../..
Fonctions
=========
Par défaut, une fonction renvoie `None`

    >>> fib(0)
    >>> print(fib(0))
    None

`return` pour définir une ou plusieurs valeur(s) de retour

    >>> def fib2(n):
    ...     """Renvoie la suite de Fibonacci jusqu'à n."""
    ...     result = []
    ...     a, b = 0, 1
    ...     while a < n:
    ...         result.append(a)
    ...         a, b = b, a + b
    ...     return result
    ...
    >>> f100 = fib2(100)
    >>> f100
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
../..
Fonctions
=========
Définition de paramètres par défaut

    >>> def add(x, y=4):
    ...    return x + y
    ...
    >>> add(2)
    6
    >>> add(2, 3)
    5

../..
Fonctions
=========
Le paramètre par défaut est calculé _une fois pour toutes_ au moment de la
définition de la fonction:

    >>> i = 5
    >>> def f(arg=i):
    ...     print(arg)
    ...
    >>> i = 6
    >>> f()
    5
../..
Fonctions
=========
Le paramètre n'est évalué qu'une seule fois

    >>> def f(a, L=[]):
    ...    L.append(a)
    ...    return L
    ...
    >>> f(1)
    [1]
    >>> f(2)
    [1, 2]
@pause

    >>> def f(a, L=None):
    ...    if L is None:
    ...        L = []
    ...    L.append(a)
    ...    return L
    ...
    >>> f(1)
    [1]
    >>> f(2)
    [2]
    >>> f(1, [0])
    [0, 1]

../..
Fonctions
=========

    >>> def f(x, y):
    ...     return x - y
    ...

On peut appeler une fonction avec des _arguments positionnels_:

    >>> f(1, 2)
    -1

ou des _mots-clés_:

    >>> f(y=6, x=2)
    -4
../..
Fonctions
=========
On ne peut pas donner deux fois le même argument:

    >>> def f(x, y):
    ...     return x - y
    ...
    >>> f(3, x=8)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: f() got multiple values for argument 'x'
../..
Fonctions
=========
Une fonction peut être appelée avec un nombre indéterminé d'arguments positionnels
ou mots-clés ; ils sont gérés par des paramètres spécifiques.

    >>> def f(*args):
    ...    print(args) # tuple
    ...
    >>> f(1, 2, 'a')
    (1, 2, 'a')

@pause

    >>> def f(x, *args, **kw):
    ...    print(kw) # dictionnaire
    ...
    >>> f(1, 2, u=0, v='a')
    {'u':0, 'v':'a'}
../..
Fonctions
=========
Appel de fonction par "déballage de tuple" _(tuple unpacking)_

    >>> def f(x, y):
    ...     return x + y
    ...
    >>> t = (3, 5)
    >>> f(*t) # comme f(3, 5)
    8

ou par "déballage de dictionnaire" _(dict unpacking)_

    >>> d = {'x':3,'y':5}
    >>> f(**d) # comme f(x=3, y=5)
    8
../..
@index List comprehensions
Listes
======
Création par _list comprehensions_

    >>> [x for x in range(5)]
    [0, 1, 2, 3, 4]
    >>> [x * 2 for x in range(5)]
    [0, 2, 4, 6, 8]
    >>> [x * 2 for x in range(5) if x != 3]
    [0, 2, 4, 8]

../..
Listes
======
Imbrication de _list comprehensions_

    >>> matrix = [
    ...     [1, 2, 3, 4],
    ...     [5, 6, 7, 8],
    ...     [9, 10, 11, 12],
    ... ]
    ...
    >>> [[row[i] for row in matrix] for i in range(4)]
    [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
../..
@index Ensembles (set)
Ensemble (`set`)
================
Comme une liste, mais sans duplication ni ordre

    >>> panier = {'pomme', 'orange', 'pomme', 'poire', 'orange', 'banane'}
    >>> panier     # les doublons sont éliminés
    {'banane', 'poire', 'pomme', 'orange'} # Python 3
    >>> 'orange' in panier
    True
    >>> 'abricot' in panier
    False

ou création par _set comprehensions_

    >>> a = {x for x in 'abracadabra' if x not in 'abc'}
    >>> a
    {'r', 'd'}
../..
Ensemble
========

    >>> panier.add('abricot')
    >>> panier
    {'banane', 'poire', 'abricot', 'pomme', 'orange'}

Intersection d'ensembles

    >>> couleurs = {'bleu', 'jaune', 'orange'}
    >>> panier & couleurs
    {'orange'}

Union

    >>> panier | couleurs
    {'jaune', 'poire', 'banane', 'abricot', 'bleu', 'pomme', 'orange'}
../..
@index Dictionnaires
Dictionnaires
=============
Associe une clé (immuable : chaine, entier, tuple...) à une valeur

    >>> tel = {'jack': 4098, 'sape': 4139} # création
    >>> tel['guido'] = 4127                # ajoute un nouvel élément
    >>> tel
    {'sape': 4139, 'guido': 4127, 'jack': 4098}
    >>> tel['jack']                        # accès par clé
    4098
    >>> tel['jack'] = 4099                 # changement de valeur
    >>> del tel['sape']                    # suppression
    >>> tel['irv'] = 4127
    >>> tel
    {'guido': 4127, 'irv': 4127, 'jack': 4099}
    >>> 'guido' in tel                     # test d'appartenance (clé)
    True
    >>> 'jack' not in tel
    False

../..
Dictionnaires
=============

    >>> tel['jenny']
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    KeyError: 'jenny'
    >>> tel.get('guido')
    4127
    >>> tel.get('jenny') # renvoie None
    >>> tel.get('jenny', 4000) # valeur par défaut
    4000

../..
Dictionnaires
=============

`tel.keys()` renvoie :

- la liste des clés en Python 2
- un itérable sur la liste des clés en Python 3

Même chose pour `tel.values()` (valeurs) et `tel.items()` (tuples clé, valeur)

    >>> for key, value in tel.items():
    ...     print(key, "'s number is", value)
    ...
    jack 's number is 4099
    irv 's number is 4127
    guido 's number is 4127

../..
Dictionnaires
=============
Itérer sur un dictionnaire c'est itérer sur ses clés

    >>> for key in tel:
    ...     print(key)
    ...
    irv
    guido
    jack

contrairement aux listes qui itèrent sur les valeurs

    >>> for value in [1, 'a']:
    ...     print(value)
    ...
    1
    'a'

../..
Dictionnaires
=============
Construction par `dict`
    >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
    {'sape': 4139, 'jack': 4098, 'guido': 4127}

ou par _dict comprehensions_

    >>> {x: x ** 2 for x in (2, 4, 6)}
    {2: 4, 4: 16, 6: 36}
../..
@index Itérations
Itérations
==========
Pour affecter plusieurs variables à la fois

    >>> a, b, c = x

itère sur x et affecte les valeurs

    >>> a, b, c = range(3)
    >>> c
    2
    >>> a, b = {3: 9, 10: 20}
    >>> b
    10

Il faut le même nombre de valeurs des deux côtés !
../..
Itérations
==========
`enumerate` pour itérer sur le tuple (rang, valeur)

    >>> for i, ville in enumerate(['bordeaux', 'rennes']):
    ...     print(i, ville)
    ...
    0 bordeaux
    1 rennes

plus "pythonique" que :

    >>> villes = ['bordeaux', 'rennes']
    >>> for i in range(len(villes)):   # ouh le débutant !
    ...     print(i, villes[i])
    ...
    0 bordeaux
    1 rennes
../..
Itérations
==========
`zip` pour itérer sur plusieurs séquences à la fois

    >>> questions = ['name', 'quest', 'favorite color']
    >>> answers = ['lancelot', 'the holy grail', 'blue']
    >>> for q, a in zip(questions, answers):
    ...     print('What is your ' + q + '?  It is ' + a)
    ...
    What is your name?  It is lancelot.
    What is your quest?  It is the holy grail.
    What is your favorite color?  It is blue.
../..
@index Scripts, modules, packages
Scripts
=======
Enregistrement du programme dans un fichier _script.py_

    `python
    for i in range(5):
        print(i)

Dans l'invite de commandes, aller dans le répertoire de _script.py_ et exécuter

    `console
    C:\test python>python script.py
    0
    1
    2
    3
    4

../..
Modules
=======
Sauvegarde dans un fichier fibo.py

    `python
    def fib(n):
        """Write Fibonacci series up to n."""
        a, b = 0, 1
        while b < n:
            print(b, end=' ')
            a, b = b, a + b
        print()
    
    def fib2(n):
        """Return Fibonacci series up to n."""
        result = []
        a, b = 0, 1
        while b < n:
            result.append(b)
            a, b = b, a + b
        return result
../..
Modules
=======

`import` pour importer un module

    >>> import fibo
    >>> fibo.fib(1000)
    1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
    >>> fibo.fib2(100)
    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    >>> fibo.__name__
    'fibo'
../..
Modules
=======
`from X import n1, n2...` pour importer des noms d'un module

    >>> from fibo import fib, fib2
    >>> fib(500)
    1 1 2 3 5 8 13 21 34 55 89 144 233 377

`from X import *` pour importer tous les noms du module _(attention aux conflits de noms !)_

    >>> from fibo import *
    >>> fib2(100)
    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

alias : `from X import un_nom_de_fonction_tres_long as f`

../..
Modules
=======
Recherche d'un module par son nom :

- dans la librairie standard
- puis dans le répertoire courant
- puis dans `Lib/site-packages` (modules tiers)

Arborescence de fichiers :

```raw
+ mes_scripts
    test.py
    mon_module.py
```

dans test.py :

    `python
    import os            # biblithèque standard
    import mon_module    # répertoire courant

../..
Packages
========
Pour structurer des librairies qui contiennent plusieurs modules

Organisation en répertoires qui contiennent un fichier *\_\_init\_\_.py*

```raw
+ sound
    __init__.py
    + formats
        __init__.py
        wavread.py
        ...
    + effects
        __init__.py
        echo.py
```

    `python
    import sound
    import sound.formats
    from sound.formats import wavread
../..
La fonction `dir()`
===================
pour inspecter les noms définis par un module

    >>> import fibo, sys
    >>> dir(fibo)
    ['__name__', 'fib', 'fib2']

Sans arguments : liste les noms définis dans le module courant

    >>> a = [1, 2, 3, 4, 5]
    >>> import fibo
    >>> fib = fibo.fib
    >>> dir()
    ['__builtins__', '__doc__', '__file__', '__name__', 'a', 'fib', 'fibo']
../..
@index Formattage de chaines
`str.format()`
==============
Permet de mettre en forme une chaine de caractères selon certains paramètres.

Exemple :

    >>> print('We are the {} who say "{}!"'.format('knights', 'Ni'))
    We are the knights who say "Ni!"

Les séquences `{}` sont remplacées par les arguments de `format`.

On peut spécifier le rang de l'argument à insérer

    >>> print('{0} and {1}'.format('spam', 'eggs'))
    spam and eggs
    >>> print('{1} and {0}'.format('spam', 'eggs'))
    eggs and spam
../..
`str.format()`
==============
On peut spécifier des mots-clés

    >>> print('This {food} is {adjective}.'.format(
    ...       food='spam', adjective='absolutely horrible'))
    This spam is absolutely horrible.

et mélanger rang et mots-clés

    >>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
    ...                                                    other='Georg'))
    The story of Bill, Manfred, and Georg.
../..
`str.format()`
==============
On peut spécifier le nombre de décimales à utiliser

    >>> import math
    >>> print('The value of PI is approximately {0:.3f}.'.format(math.pi))
    The value of PI is approximately 3.142

et le nombre minimal de caractères

    >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
    >>> for name, phone in table.items():
    ...     print('{0:10} ==> {1:10d}'.format(name, phone))
    ...
    Jack       ==>       4098
    Dcab       ==>       7678
    Sjoerd     ==>       4127
../..
@index Fichiers
Fichiers
========

<code>open(_filename, mode, encoding_)</code>

Le *mode* peut être

- 'r' : lecture seule (valeur par défaut)
- 'a' : écriture en fin de fichier
- 'w' : effacement si le fichier existe déjà, puis écriture

Sur Windows, ajouter 'b' pour ouvrir les fichiers en mode binaire ('rb', 'wb'...)

../..
Fichiers
========

<code>open(_filename, mode, encoding_)</code>

*encoding* spécifie l'encodage d'un fichier texte (la table de conversion
entre un caractère et un ou plusieurs octets) :

- 'utf-8' : convertit le caractère __é__ en deux octets : __c3 a9__
- 'latin-1' : convertit __é__ en un octet : __e9__
- 'ascii' : ne sait pas convertir les caractères accentués

_Il faut spécifier l'encodage systématiquement_ : les valeurs par défaut varient
selon les OS, les versions, etc.

*encoding* doit être passé comme argument mot-clé :

    `python
    f = open("fichier.txt", "r", encoding="utf-8")

../..
Fichiers
========
<code>f.read(_nb_)</code> pour lire au plus _nb_ octets. Renvoie la chaine vide `''` en fin de fichier

`f.read()` pour lire tout le fichier

`f.readline()`: lit une ligne ; se termine par `\n`, ou `''` en fin de fichier

`f.readlines()` lit toutes les lignes et les met dans un tableau

Itération sur les lignes :

    `python
    f = open("fichier.txt", "r", encoding="utf-8")
    for line in f:
        ...

../..
Fichiers
========
<code>f.write(_data_)</code> pour écrire la chaine _data_ dans le fichier

    >>> f.write('This is a test\n')

Pour écrire autre chose qu'une chaine, il faut d'abord convertir en chaine par `str()`

    >>> f.write(42)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: expected a character buffer object
    >>> f.write(str(42))

../..
Fichiers
========
<code>f.seek(_x_)</code> positionne le pointeur à la position _x_

`f.tell()` renvoie la position courante du pointeur

`f.close()` ferme le fichier et libère les ressources associées

Utiliser de préférence `with` pour ne pas avoir à fermer explicitement

    >>> with open('/tmp/workfile', 'rb') as f:
    ...     read_data = f.read()
    >>> f.closed
    True
../..
Sérialisation : le module `json`
==================================
Limité aux types simples : nombres, chaines de caractères, listes, dictionnaires
dont les clés sont des chaines de caractères.

    `python
    import json
    json.dump(x, f) # écrit l'objet x dans le fichier f
    
    obj = json.load(f) # récupère l'objet x depuis le fichier f

Format universel.
../..
@index Erreurs et exceptions
Erreurs et exceptions
=====================
Python distingue :

- les erreurs : détectées dans la phase d'analyse du programme
 - erreurs de syntaxe
 - erreur d'indentation

- les exceptions : surviennent pendant l'exécution d'un programme
../..
Erreurs
=======
`SyntaxError`
    >>> while True print 'Hello world'
      File "<stdin>", line 1, in ?
        while True print 'Hello world'
                       ^
    SyntaxError: invalid syntax

`IndentationError`
    >>> for i in range(5):
    ... print i
      File "<stdin>", line 2
        print i
            ^
    IndentationError: expected an indented block

../..
Exceptions
==========
Exemples :

    >>> 10 * (1 / 0)
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    ZeroDivisionError: integer division or modulo by zero

    >>> 4 + spam * 3
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    NameError: name 'spam' is not defined

    >>> '2' + 2
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: cannot concatenate 'str' and 'int' objects
../..
Exceptions
==========
`try ... except` pour gérer des exceptions

    >>> while True:
    ...     try:
    ...         x = int(input("Veuillez entrer un nombre: "))
    ...         break
    ...     except ValueError:
    ...         print("Ce n'est pas un nombre valide. Recommencez...")
    ...

Si une instruction du bloc `try` déclenche une exception, on arrête l'exécution du bloc

Si l'exception est du type spécifié dans `except` on exécute le bloc de cet `except`
../..
Exceptions
==========
Variantes de `except` :

    `python
    try:
        ...
    except IOError:
        ...
    except (TypeError, ValueError): # plusieurs types d'exceptions
        ...
    except:        # toutes les exceptions non encore gérées
        ...
../..
Exceptions
==========
`else` si aucune exception n'a été déclenchée

    `python
    try:
        f()
    except:
        print('erreur')
    else:
        suite()

@pause

Presque équivalent à 

    `python
    try:
        f()
        suite()
    except:
        print('erreur')

sauf si `suite()` déclenche une exception...
../..
Exceptions
==========
`as` pour récupérer l'objet exception

    >>> x = [6]
    ... try:
    ...     x[2]
    ... except IndexError as exc:
    ...    print('erreur index', exc)
    ...
    ('erreur index', IndexError('list index out of range',))

L'objet `exc` est une _instance_ de la _classe_ `IndexError`
../..
Exceptions
==========
`raise` pour déclencher des exceptions

    >>> def racine(x):
    ...     if x < 0:
    ...         raise ValueError('nombre négatif')
    ...
    >>> racine(-6)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 3, in racine
    ValueError: nombre négatif
    >>>
../..
Exceptions
==========
Sans argument : re-déclenche la dernière exception gérée

    >>> valeur = -1
    >>> try:
    ...     racine(valeur)
    ... except ValueError:
    ...     print('erreur pour la valeur', valeur)
    ...     raise
    ...
    erreur pour la valeur -1
    Traceback (most recent call last):
      File "<stdin>", line 2, in <module>
      File "<stdin>", line 3, in racine
    ValueError: nombre négatif

../..
Exceptions
==========
`finally` pour exécuter un code qu'il y ait eu exception ou pas

Si une exception n'a pas été gérée, elle est déclenchée après `finally`

    >>> x = [5]
    >>> try:
    ...     print(x[2])
    ... finally:
    ...     print('Goodbye, world!')
    ...
    Goodbye, world!
    Traceback (most recent call last):
      File "<stdin>", line 2, in <module>
    IndexError: list index out of range

../..
Exceptions
==========
    >>> def divise(x, y):
    ...     try:
    ...         result = x / y
    ...     except ZeroDivisionError:
    ...         print("division par zero!")
    ...     else:
    ...         print("le resultat est", result)
    ...     finally:
    ...         print("fin de fonction")
    ...
    >>> divise(2, 1)
    le resultat est 2
    fin de fonction

    >>> divise(2, 0)
    division par zero!
    fin de fonction

../..
Exceptions
==========
    >>> def divise(x, y):
    ...     try:
    ...         result = x / y
    ...     except ZeroDivisionError:
    ...         print("division par zero!")
    ...     else:
    ...         print("le resultat est", result)
    ...     finally:
    ...         print("fin de fonction")
    ...
    >>> divise("2", "1")
    fin de fonction
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
      File "<stdin>", line 3, in divise
    TypeError: unsupported operand type(s) for /: 'str' and 'str'
../..
Exceptions
==========
Mot-clé `assert`

    >>> def age(annee_naissance, annee):
    ...     assert annee_naissance <= annee, "pas né !"
    ...     return annee - annee_naissance
    ...
    >>> age(1974, 2015)
    41
    >>> age(1974, 1960)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 2, in age
    AssertionError: pas né !
    >>>

../..
@index Espaces de noms
Espaces de noms
===============
Permet de définir et d'utiliser le même nom dans des contextes différents

    >>> a = 1
    >>> def f():
    ...    a = 3
    ...    print(a)
    ...
    >>> f()
    3
    >>> a
    1
../..
Espaces de noms
===============
`global` pour forcer l'utilisation d'une variable globale

    >>> a = 1
    >>> def f():
    ...    global a
    ...    a = 3
    ...    print(a)
    ...
    >>> f()
    3
    >>> a
    3
../..
Espaces de noms
===============

    `python
    x = 0
    
    def f(x):
        import Z
    
    import X
    
    from Y import A
    
    for i in range(5):
        j = 2 * i
    
définit les noms `x, f, X, A, i, j` dans l'espace de noms global ; `x, Z` dans l'espace de noms de `f`
(aucun rapport entre les deux `x`)

NB : le nom `Y` n'est __pas__ dans l'espace de noms
../..
Espaces de noms
===============
A l'exécution, quand l'interpréteur rencontre un nom, il cherche dans l'espace
de nom le plus proche, puis "remonte" jusqu'au niveau module puis aux noms
intégrés de Python

    `python
    a = 6
    def f():
        b = 8
        def g(n):
            print(n)
            print(b)
            print(a)
        g(8)

Dans l'exécution de g :

- pas de nom `print` dans les espaces locaux ni globaux, mais `print` est une
  fonction intégrée de Python
- le nom `n` est dans l'espace de noms de g
- pas de nom `b` dans l'espace de noms de g, on remonte jusqu'à l'espace de
  noms de f
- pas de nom `a` dans l'espace de noms de g ni de f, on remonte jusqu'à
  l'espace de noms global
../..
Espaces de noms
===============
Un nom défini ("bound") dans un bloc est local à ce bloc.

    >>> a = 0
    >>> def f():
    ...   print(a)
    ...   a = 1
    ...
    >>> f()
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 2, in f
    UnboundLocalError: local variable 'a' referenced before assignment
    >>>

../..
@index Classes
Classes
=======
Définis par le mot clé `class`

    `python
    class ClassName:
        <statement-1>
        .
        .
        .
        <statement-N>
    
Le nom `ClassName` est ajouté dans l'espace de noms où la classe est définie.

Une classe possède son propre espace de noms.
../..
Classes
=======

    >>> class MyClass:
    ...    i = 12345
    ...
    >>> print(MyClass.i)

Les noms définis dans `MyClass` (_attributs_) sont accessibles depuis l'espace de noms "supérieur" par des _noms qualifiés_ (forme `klass.X`)

On peut modifier dynamiquement les attributs de la classe

    >>> MyClass.i = 23456

et ajouter des attributs de classe "à la volée" : 

    >>> MyClass.j = 8
    >>> MyClass.j
    8

../..
Classes
=======
Pour créer des instances d'une classe, on l'utilise comme une fonction :

    >>> class MyClass:
    ...    i = 12345
    ...
    >>> x = MyClass()

L'instance possède les mêmes attributs que la classe

    >>> x.i
    12345

On peut ajouter des attributs d'instance "à la volée" :

    >>> x.name = "homer"
    >>> x.name
    'homer'
    
../..
Classes
=======
Les _fonctions_ définies dans la classe deviennent les _méthodes_ des instances de cette classe

Par convention, on les écrit avec l'instance comme premier argument, appelé `self`

    >>> class MyClass:
    ...
    ...     def f(self):
    ...         print('hello')
    ...
    ...     def greet(self, name):
    ...         print('hello, ', name)
    ...
    >>> x = MyClass()
    >>> x.f()
    hello
    >>> x.greet('world')
    hello, world

`x.greet('world')` est équivalent à  `MyClass.greet(x,'world')`

../..
Classes
=======
Pour initialiser une instance avec des attributs spécifiques : fonction spéciale `__init__()`

    >>> class MyClass:
    ...     def __init__(self):
    ...         self.data = []
    ...
    >>> x = MyClass()
    >>> x.data
    []
../..
Classes
=======
Bien distinguer attributs de classe (partagés entre toutes les instances)

    >>> class A:
    ...     data = []
    ...
    >>> a = A()
    >>> a.data.append(1)
    >>> b = A()
    >>> b.data
    [1]
et attributs propres à chaque instance
    >>> class B:
    ...     def __init__(self):
    ...         self.data = []
    ...
    >>> a = B()
    >>> a.data.append(1)
    >>> b = B()
    >>> b.data
    []
../..
Classes
=======
On peut passer des arguments à la fonction `__init__`

    >>> class Complex:
    ...     def __init__(self, realpart, imagpart):
    ...         self.r = realpart
    ...         self.i = imagpart
    ...
    >>> x = Complex(3.0, -4.5)
    >>> x.r, x.i
    (3.0, -4.5)
../..
Classes
=======
Les méthodes peuvent appeler d'autres méthodes

    `python
    class Bag:
    
        def __init__(self):
            self.data = []
    
        def add(self, x):
            self.data.append(x)
    
        def addtwice(self, x):
            self.add(x)
            self.add(x)
../..
Héritage
========

    `python
    class DerivedClass(BaseClass):
        <statement-1>
        .
        .
        .
        <statement-N>

`DerivedClass` _hérite_, ou est _dérivée_, ou est une _sous-classe_ de `BaseClass`
../..
Héritage
========

    >>> class A:
    ...     x = 0
    ...
    >>> class B(A):
    ...     y = 1
    ...
    >>> obj = B()
    >>> obj.y
    1
    >>> obj.x
    0

La recherche (_résolution_) d'attribut est exécutée dans la classe B, puis dans la classe A dont B hérite
../..
Héritage
========
Une sous-classe peut réécrire (_surcharger_) les fonctions de la classe dont elle hérite

    `python
    class A:
        x = 0
        def show(self):
            print('je suis A')
    
    class B(A):
        def show(self):
            print('je suis B')
../..
Héritage
========
On peut utiliser les fonctions de A dans les fonctions de B

    `python
    class A:
        def __init__(self, x):
            self.x = x ** 2
    
    class B(A):
        def __init__(self, x, y):
            A.__init__(self, x)
            self.y = y
../..
Héritage
========
Exemple : les modules peuvent définir des _classes_ d'exception spécifiques, dérivées de la classe `Exception`

    >>> class MyError(Exception):
    ...     def __init__(self, value):
    ...         self.value = value
    ...
    >>> try:
    ...     raise MyError(4)
    ... except MyError as e:
    ...     print('My exception occurred, value:', e.value)
    ...
    My exception occurred, value: 4

`MyError(4)` crée une _instance_ de la classe `MyError` en passant l'argument `4`

La méthode `__init__(self, value)` initialise l'instance avec l'argument _value_
../..
Héritage
========
Héritage multiple

    `python
    class Derived(Base1, Base2, Base3):
        <statement-1>
        .
        .
        .
        <statement-N>

Construit pour la classe `Derived` un _ordre de résolution de méthodes_ (MRO) 
pour la résolution d'attributs ; exception en cas d'impossibilité.
../..
Héritage
========
Ordre de résolution quand 2 classes parentes définissent le même attribut
    >>> class A:
    ...     info = "classe A"
    ...
    >>> class B:
    ...     info = "classe B"
    ...
    >>> class C(A, B):
    ...     pass
    ...
    >>> C().info
    'classe A'
    >>> class D(B, A):
    ...     pass
    ...
    >>> D().info
    'classe B'

../..
Héritage
========
<code>issubclass(_A, B_)</code> teste si la classe _A_ hérite de la classe _B_

<code>isinstance(_obj, A_)</code> teste si l'objet _obj_ est une instance de _A_
ou d'une classe qui hérite de _A_

Variante :  <code>isinstance(_obj, [A, B]_)</code>

    `python
    def carre(x):
        if not isinstance(x, [int, float]):
            raise ValueError("l'argument n'est pas un nombre")
        return x * x

../..
Méthodes spéciales
==================
`__str__(self)` pour définir le résultat de `print(objet)`

    `python
    class A:
    
        def __init__(self, nom, prenom):
            self.nom = nom
            self.prenom = prenom
    
        def __str__(self):
            return '{} {}'.format(self.prenom, self.nom)
    
    x = A('Einstein', 'Albert')
    print(x)

../..
Méthodes spéciales
==================
`__getitem__(`<code>_self, pos_)</code> pour définir l'accès par index

    >>> class A:
    ...     def __init__(self):
    ...         self.data = 'la cigale et la fourmi'
    ...     def __getitem__(self, i):
    ...         return self.data[i]
    ...
    >>> x = A()
    >>> x[3]
    c
../..
Méthodes spéciales
==================
`__mul__`<code>(_self, other_)</code> pour définir la multiplication d'une
instance par _other_

    >>> class Vecteur:
    ...     def __init__(self, x, y):
    ...         self.x = x
    ...         self.y = y
    ...     def __mul__(self, vec):
    ...         return self.x * vec.x + self.y * vec.y
    ...
    >>> Vecteur(2,3) * Vecteur(-1,2)
    4

de même : `__add__, __sub__, __div__, __pow__ ...`

`__eq__` pour tester l'égalité, `__ne__` pour inégalité

`__le__` pour <=
`__gt__` pour > etc.

../..
@index Itérateurs, générateurs
Itérateurs
==========
Utilisés très fréquemment en Python

    `python
    for element in [1, 2, 3]:
        ...
    
    for element in (1, 2, 3):
        ...
    
    for key in {'one':1, 'two':2}:
        ...
    
    for char in "123":
        ...
    
    for line in open("myfile.txt"):
        ...
../..
Itérateurs
==========
Pour pouvoir itérer sur une instance d'une classe, la classe doit définir une
fonction `__iter__`, qui renvoie un objet qui possède une méthode `__next__`

`__next__` déclenche `StopIteration` quand l'itération est finie.

    `python
    class Reverse:
        """Iterateur pour parcourir une séquence à l'envers."""
    
        def __init__(self, data):
            self.data = data
            self.index = len(data)
    
        def __iter__(self):
            return self
    
        def __next__(self):
            if self.index == 0:
                raise StopIteration
            self.index -= 1
            return self.data[self.index]
../..
Générateurs
===========
Création automatique d'itérateurs : fonctions qui utilisent `yield` au lieu de `return`

    >>> def gen():
    ...     yield 1
    ...     yield 2
    ...
    >>> it = gen()
    >>> next(it)
    1
    >>> next(it)
    2

Chaque appel de `next()` reprend l'exécution de la fonction à l'endroit où
elle s'était arrêtée à l'itération précédente.

../..
Générateurs
===========
Générateur infini

    >>> def gen():
    ...     i = 0
    ...     while True:
    ...         yield i
    ...         i += 1
    ...
    >>> it = gen()
    >>> next(it)
    0
    >>> next(it)
    1

Entre deux appels de `next()` les variables locales sont conservées

../..
Générateurs
===========
Exemple : itérateur sur tous les nombres premiers supérieurs à un seuil

    >>> def premiers(n):
    ...     while True:
    ...         if est_premier(n):
    ...             yield n
    ...         n += 1
    ...
../..
Générateurs
===========

`return` dans un générateur termine l'itération

    >>> def enter():
    ...     while True:
    ...         t = input('? ')
    ...         if not t:
    ...             return
    ...         yield 'bonjour ' + t
    ...
    >>> for item in enter():
    ...     print(item)
    ...
    ? essai
    bonjour essai
    ? coucou
    bonjour coucou
    ?
    >>>


../..
Generator expressions
=====================
Simplifie le passage d'argument à une fonction qui attend un itérateur

    >>> sum(i * i for i in range(10))
    285

    >>> xvec = [10, 20, 30]
    >>> yvec = [7, 5, 3]
    >>> sum(x * y for x, y in zip(xvec, yvec))
    260

    >>> unique_words = set(word for line in page for word in line.split())
../..
@index Décorateurs
Décorateurs
===========
Fonction qui renvoie une autre fonction, utilisée avec `@`

    `python
    @controle
    def f(...):
        ...

équivaut à

    `python
    def f(...):
        ...
    f = controle(f)

../..
Décorateurs
===========
Exemple : vérifier qu'une fonction renvoie un entier

    `python
    def check_int(func):
        def g(*args, **kw):
            res = func(*args, **kw)
            assert isinstance(res, int)
            return res
        return g
    
    @check_int
    def f(x):
        return x*2
    
    f(1)
    f('a')

../..
@index Bonnes pratiques
Quelques bonnes pratiques
=========================
Référence : [PEP 8](https://www.python.org/dev/peps/pep-0008/)

_Le code est plus souvent lu qu'écrit_

- indentation : 4 espaces
- lignes : pas plus de 79 caractères

- docstring au début d'un module, d'une fonction, d'une classe

    `python
    def insort_left(a, x, lo=0, hi=None):
        """Insert item x in list a, and keep it sorted assuming a is sorted.
        
        If x is already in a, insert it to the left of the leftmost x.
        
        Optional args lo (default 0) and hi (default len(a)) bound the
        slice of a to be searched.
        """

La chaine devient l'attribut `__doc__` du module, de la fonction, de la
classe.

../..
Quelques bonnes pratiques
=========================
- nom des variables : plus d'une lettre ; pas "I" ou "l" ; pas un nom intégré

    >>> list = ['a', 'b', 'c']

100 lignes plus loin...

    >>> items = list(name)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: 'list' object is not callable

- nom des modules en minuscule ; nom des classes commence par une majuscule ;
  constantes tout en majuscules

- `variable_avec_tiret_bas` plutôt que `variableAvecTiretBas`

- plutôt 5 lignes lisibles qu'une ligne illisible : boucles `for` indentées
  plutôt que des _list comprehensions_ complexes

../..
Quelques bonnes pratiques
=========================
Des tests, des tests, des tests...

    `python
    import unittest
    from fibo import fib2

    
    class FibonacciTestCase(unittest.TestCase):
    
        def testFibonacciLowerThan4(self):
            expected = [1, 1, 2, 3]
            obtained = fib2(4)
            self.assertEqual(expected, obtained)
    
        def testFibonacciWith0ShouldReturnEmptyList(self):
            self.assertEqual([], fib2(0))
    
    unittest.main()

../..
@index Librairie standard
Librairie standard : `os`
==========================

    >>> import os
    >>> os.getcwd()      # renvoie le répertoire courant
    'C:\\Python26'
    >>> os.chdir('/server/accesslogs')   # Change le répertoire courant
    >>> os.mkdir('nouveau') # crée un nouveau répertoire
    >>> os.rmdir('nouveau') # supprime un répertoire

    >>> os.path.join('rep1', 'rep2', 'fichier.txt')
    'rep1\\rep2\\fichier.txt'
../..
Librairie standard : `shutil`
=============================
Utilitaires de manipulation de fichiers et de répertoires

    >>> import shutil
    >>> shutil.copyfile('data.db', 'archive.db') # recopie
    >>> shutil.move('/build/executables', 'installdir') # déplacement
../..
Librairie standard : `sys`
==========================
Arguments passés en ligne de commande (_python demo.py one two three_)

Dans _demo.py_

    `python
    import sys
    print(sys.argv) # liste des arguments passés après "python"
    ['demo.py', 'one', 'two', 'three']

Entrée et sortie standard : `sys.stdin, sys.stdout`

    `python
    sys.stdout.write('data')

Peut être modifié pour rediriger la sortie de `print`

    `python
    sys.stdout = file_obj # un objet avec une méthode write
    print('data')         # équivaut à file_obj.write('data\n')
../..
Librairie standard : `re` (expressions régulières)
==================================================
Fonctions avancées de recherche et remplacement de chaines de caractères

    >>> import re
    >>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
    ['foot', 'fell', 'fastest']
    >>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
    'cat in the hat'
../..
Librairie standard : `math`
===========================
Fonctions mathématiques

    >>> import math
    >>> math.cos(math.pi / 4.0)
    0.70710678118654757
    >>> math.log(1024, 2)
    10.0
../..
Librairie standard : `random`
=============================
Fonctions aléatoires

    >>> import random
    >>> random.choice(['apple', 'pear', 'banana'])
    'apple'
    >>> random.sample(range(100), 10)   # échantillon
    [30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
    >>> random.random()    # random float
    0.17970987693706186
    >>> random.randrange(6)    # entier dans range(6)
    4
../..
Librairie standard : `datetime`
===============================
Heures et dates

    >>> from datetime import date
    >>> now = date.today()
    >>> now
    datetime.date(2003, 12, 2)
    >>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
    '12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'

Opérations sur les dates

    >>> birthday = date(1964, 7, 31)
    >>> age = now - birthday
    >>> age.days
    14368
../..
Librairie standard : compression
================================
Modules standard `zlib, gzip, bz2, zipfile, tarfile`

    >>> import zlib
    >>> s = 'witch which has which witches wrist watch'
    >>> len(s)
    41
    >>> t = zlib.compress(s)
    >>> len(t)
    37
    >>> zlib.decompress(t)
    'witch which has which witches wrist watch'
    >>> zlib.crc32(s)
    226805979

../..
Installation de packages tiers
==============================

Programme `pip` pour installer un package déposé sur le
Python Package Index

    `console
    pip install flask

`pip` installe automatiquement les packages dont dépend __flask__.

Le package est ensuite disponible dans l'interpréteur :

    >>> from flask import Flask
    